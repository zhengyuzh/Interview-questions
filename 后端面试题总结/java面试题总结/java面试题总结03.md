


# 21、对线程安全的理解
不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问

当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。

- ==堆==是进程和线程共有的空间，分全局堆和局部堆。==全局堆==就是所有没有分配的空间，==局部堆==就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统，要不然就是==内存泄漏==

在java中，堆是java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

- ==栈==是每个线程独有的，保存其==运行状态==和==局部自动变量==的。栈在线程开始的时候初始化，每个线程的栈==相互独立==，因此，栈是==线程安全==的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显示的分配和释放。

目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程的所有线程都可以访问到该区域，这就是造成问题的潜在原因。
- =============
# 22、Thread和Runnable的区别
Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread,都会new Thread，然后执行run()方法。用法上，如果有复杂的线程操作需求，那就选择==继承Thread==，如果知识简单的执行一个任务，那就==实现Runnable==

- =============
# 23、说说你对守护线程的理解
==守护线程==：为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保姆；
守护线程类似于整个进程的一个默默无闻的小喽啰；它的生死无关重要，它却依赖整个进程而运行；哪天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；

==注意：由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因为它不靠谱；==

守护线程的作用是什么？
举例，GC垃圾回收线程：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它开始终再低级别的状态中运行，用于实时监控和管理系统中的可回收资源。

**应用场景：**
- 1、来为其它线程提供服务支持的情况；
- 2、或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。


`thread.setDaemon(true)`必须在`thread.start()`之前设置，否则会抛出一个`IllegalThreadException`异常。你不能把正在运行的常规线程设置为守护线程。

在Daemon线程中产生的新线程也是Daemon的。

守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断

java自带的多线程框架，比如ExecutorService,会将守护线程转换为用户线程，所以如果要使用后台线程就不能用java的线程池。

- =============
# 24、ThreadLocal的原理和使用场景
每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程中所有ThreadLocal对象及其对应的值

ThreadLocalMap由一个个Entry对象构成。

`Entry`继承自`WeakReference<ThreadLocal<?>>`，一个`Entry`由`ThreadLocal`对象和`object`构成。由此可见，`Entry`的key是`ThreadLocal`对象，并且是一个弱引用，当没指向key的强引用后，该key就会被垃圾收集器回收。

当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。

get方法执行过程类似，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。

由于每一条线程均含有各自==私有的==ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。

**使用场景：**
- 1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束
- 2、线程间数据隔离
- 3、进行事务操作，用于存储线程事务信息。



# 25、ThreadLocal内存泄漏问题，如何避免
内存泄漏为程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重，无论多少内存，迟早会被占光。

不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄漏。

==强引用==：使用最普遍的引用（new），一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，java虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，也不回收这种对象。

如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样就可以使JVM在合适的时间就会回收该对象。

==弱引用==：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用`java.lang.ref.WeakReference`类来表示。可以在缓存中使用弱引用。


ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1d333d528a64a77a35148d07a0d1372.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p-x5ZCM5a2m6KaB5Yqq5Yqb,size_20,color_FFFFFF,t_70,g_se,x_16)
hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，key（ThreadLocal）势必会被GC回收，这样就会导致ThreadLocalMap中key为null，而value还存在这强引用，只有thead线程退出以后value的强引用链条才会断掉，但如果当前现线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链（红色链条）

**key使用强引用**

当threadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。

**key的弱引用**

当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get(),remove()方法的时候会被清除value值

**ThreadLocal正确的使用方法**

- 每次使用完ThreadLocal都调用它的remove()方法清除数据
- 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。
- =============
# 26、并发、并行、串行
- ==串行==在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着
- ==并行==在时间上是重叠的，两个任务在==同一个时刻==互不干扰的同时执行
- ==并发==允许两个任务彼此干扰。统一时间点，只有一个任务运行，==交替执行==。

- =============
# 27、并发三大特性
**==原子性==**

- 原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括两个操作：从账户A减去1000元，往账户B加上1000元。2个操作必须全部完成。

**==可见性==**

- 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
若两个线程在不同的cpu，那么线程A改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之气的，线程1对变量的修改线程2没有看到这就是可见性问题

**==有序性==**

- 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重新排序。实际上，对于有些代码进行排序之后，虽然对变量的值没有造成影响，但由肯能会出现线程安全问题


# 28、为什么使用线程池？解释下线程池解释？
1、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗
2、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。
3、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控
- `corepoolsize`代表核心线程数，也就是正常情况下创建工作线程的线程数，这些线程创建后并不会消除，而是一种常驻线程。

- `maxinumpoolsize`代表的是最大的线程数，它与核心线程数相对应，表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但是线程池内线程总数不会超过最大线程数

- `keepAliveTime、unit`表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会消除，但是超出核心线程的部分线程如果空闲一定的时间会被消除，我们可以通过setKeepAliveTime来设置空闲时间

- `workQueue`用来存放待执行的任务，假设我们现在核心线程都已被停用，还有任务进来则全部放入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程。
- `ThreadFactory`实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建工厂，产生的线程都会在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择自定义线程工厂，一般我们会根据业务来指定不同的线程工厂

- handler任务拒绝策略，有两种情况，第一种是当我们调用shutdown等方法关闭线程池后，这时候即使线程池内部还有执行完的任务正在执行，但是由于线程池已经关闭，我们在继续向线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提交的任务时，这也是拒绝

# 29、线程池处理流程
![在这里插入图片描述](https://img-blog.csdnimg.cn/87c8a4ff64724f42b94693d537a35943.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p-x5ZCM5a2m6KaB5Yqq5Yqb,size_14,color_FFFFFF,t_70,g_se,x_16)



# 30、线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？

1、一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。

阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。

阻塞队列自带阻塞和唤醒功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占用cpu资源


2、在创建新线程的时候，是要获取全局锁的，这个时候其它的就得阻塞，影响了整体效率。

就好比一个企业里有10个（core）正式工的名额，最多招10个正式工，要是任务超过正式人工数（task>core）的情况下、工厂领导（线程池）不是首先扩招工人，还是这10个人，但是任务可以稍微积压一下，即先放到队列区（代价低）。10个正式工慢慢干，迟早会干完的。要是任务还在继续增加，超过正式工的加班忍耐极限了（队列满了），就的招外包帮忙了（注意是临时工）要是正式工加上外包还是不能完成任务，那新来的任务就会被领导拒绝了（线程池的拒绝策略）