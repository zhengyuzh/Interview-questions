**这里是参考B站上的大佬做的面试题笔记。大家也可以去看视频讲解！！！**
@[toc]

# 61、怎么处理慢查询
**关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过?**

在业务系统中，除了使用**主键**进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有名中索引？ 是load了不需要的数据列？还是数据量太大？

所以优化也是针对这三个方向来的，
- 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的名中索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

# 62、ACID靠什么保证的
- **A原子性**由**undo log日志**保证，它记录了需要回滚的日志信息，事务回滚撤销已经执行成功的sql

- **C一致性**由其他三大特性保证、程序代码要保证业务上的一致性
- **I隔离性**由**MVCC**来保证
- **D持久层**由**内存+redo log**来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复

InnoDB redo log 写盘，InnoDB 事务进入 prepare状态。
如果前面prepare 成功，binlog 写盘，再继续将事务日志持久化到binlog，如果持久化成功，那么 InnoDB 事务则进入commit状态 redo log里面写一个 commit 记录）

redolog的刷盘会在系统空闲时进行

# 63、什么是MVCC
**多版本并发控制**：读取数据数据时通过一种==类似快照==的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务session会看到自己特定版本的数据，版本链

MVVC只在`READ COMMITTED`和`REPEATABLE READ `两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为`READ UNCOMMITTED9`总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。

聚簇索引记录中有两个必要的隐藏列：
- `trx_id:`用来存储每次对某条聚簇索引记录进行修改的时候的**事务id**。

- `roll_pointer:`每次对哪条聚簇索引记录有修改的时候，都会把老版本**写入undo日志**中。这个roll_pointer就是**存了一个指针**，它指向这条聚簇索引记录上一个版本的位置，通过它来获得上一个版本的记录信息。（注意插入操作的undo日志没有这个属性，因为它没有老版本。

**已提交读**和**可重复读**的区别就在于它们**生成ReadView策略不同**。

- 开始事务时创建`readview`，`readView`维护当前活动的事务id，即未提交的事务id，排序成一个数组
- 访问数据，获取数据中的事务id（获取的时事务id最大的记录），对比readview：
- 如果在readview的左边（比readview都小），可以访问（在左边意味着该事务已经提交）
- 如果在readview的右边（比readview都大）或者就在readview中，不可以访问，获取roll_pointer，取上一版本重新对比（在右边意味着，该事务在readview生成之后出现，在readview中意味着该事务还未提交）

已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView，而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

这就是Mysql的MVVC，通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别
# 64、mysql主从同步原理
MySQL主从同步的过程：

MySQL的主从复制中有三个线程：master(binlog dumo thread)、slave(I/0 thread、SQL thread)，Master一条线程和Slave中的两条线程。
- 主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库启动的那一刻起，保存所有修改数据库结构或内容的一个文件。
- 主节点log dump 线程，当binlog有变动时，log dump线程读取其内容并发送给从节点。
- 从节点I/O线程接受binlog内容，并将其写入到relay log文件中。
- 从节点的SQL线程读取relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。

注意：从节点使用binlog文件+position偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从position的位置发起同步。

由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库上升为主库后，日志就丢失了。由此产生两个概念。

**全同步复制**

- 主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

**半同步复制**

- 和全同步不同的是，半同步复制的逻辑是这样的，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认位写操作完成。
# 65、简述Myisam和innodb的区别
**MyISAM：**

- 不支持事务，但是每次查询都是原子的；
- 支持表级锁，即每次操作是对整个表加锁
- 存储表的行总数；
- 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
- 采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅助索引与主索引基本一致，但是辅助索引不用保证唯一性。

**innoDb：**

- 支持ACID事务，支持事务的四种隔离级别；
- 支持行级锁及外键约束：因此可以支持写并发；
- 不存储行总数；
- 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
- 主键索引采用聚集索引（索引的数据域存储数据文件本身，辅助索引的数据域存储主键的值；因此从辅助索引查找数据，需要先通过辅助索引找到主键值，再访问辅助索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。




# 66、简述MySQL中索引类型对数据库的性能的影响
- **普通索引**：允许被索引的数据列包含重复的数据

- **唯一索引**：可以保证数据记录的唯一性

- **主键**：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字primary key来创建。

- **联合索引**：索引可以覆盖多个数据列，如像INDEX(columnA,columnB)索引。

- **全文索引**：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT（column);创建全文索引

**优点：**
- 索引可以极大的提高数据的查询速度。

- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点：**
- 但是会减低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件
- 索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚集索引都会跟着变。

# 67、RDB和AOF机制
RDB:Redis DataBase

在==指定的时间间隔内==将内存中的数据集快照写入磁盘，实际操作过程就是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

**优点：**
- 1、整个Redis数据库只包含一个文件dump.rdb，方便持久化
- 2、容灾性好，方便备份
- 3、性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能。
- 4、相对于数据集大时，比AOF的启动效率更高

**缺点：**
- 1、数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候）
- 2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是一秒钟。

AOF:Append Only File

以**日志的形式**记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

**优点**：

- 1、数据安全，Redis中提供了3中同步策略，即**每秒同步**、**每修改同步**和**不同步**。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统发生宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立刻记录到磁盘中。
- 2、通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题。
- AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩的目的。

**缺点**：
- 1、AOF文件比RDB文件大，且恢复速度慢
- 2、数据集大的时候，比rdb启动效率低
- 3、运行效率没有RDB高

AOF文件比RDB更新频率高，优先使用AOF还原数据
AOF比RDB更安全也更大
RDB性能比AOF好
如果两个都配置了优先加载AOF

# 68、Redis的过期键的删除策略
Redis是**key-value**数据库，我们可以设置Redis中缓存的过期时间。**Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理**。
- **惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况肯可能出现大量的过期key没有被访问，从而不会被清除，占用大量内存
- **定期过期**：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

（expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是改键的毫秒精度的UNIX时间戳表示过期的时间。键空间是指该Redis集群中保存的所有的键。）

Redis中同时使用了惰性过期和定期过期两种过期策略。
# 69、Redis线程模型，单线程为什么这么快
Redis基于Reactor模式开发了网路事件处理器，这个处理器叫做文件事件处理器 file event handler。这个文件事件处理器，它是单线程的，所以Redis才叫做单线程的模型，它采用IO多路复用机制来同时监听多个Socket，根据**Socket上的事件类型==来选择==对应的事件处理器**来处理这个事件。可以实现高性能网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性。

`文件事件处理器`的结构包含4个部分：**多个Socket**、I**O多路复用程序**、**文件事件分配器**以及**事件处理器**（命令请求处理器、命令回复处理器、连接应答处理器等）。
多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。
然后一个Socket的事件处理完之后，IO多路复用程序会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。

**单线程快的原因：**
- 1、纯内存操作
- 2、核心是基于非阻塞的IO多路复用机制
- 3、单线程反而避免了多线程的频繁上下文切换带来的性能问题

# 70、缓存雪崩、缓存穿透、缓存击穿
缓存雪崩、缓存穿透、缓存击穿

**缓存雪崩**是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决方案：
- 1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 2、给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存
- 3、缓存预热
- 4、互斥锁

**缓存穿透**是指缓存和数据库中都没有的数据，会导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决方法：

- 1、接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
- 2、从缓存取不到数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样就可以防止攻击用户反复用同一个id暴力攻击
- 3、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力


**缓存击穿**是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩式不同数据都过期了，很多数据都查不到从而查数据库。

解决方法：
- 设置热点数据永远不过期
- 加互斥锁